# パート3：セキュリティ、完全デモ、統合（10分）

## セキュリティインフラストラクチャ（3分）

> 「最終セッションへようこそ。パート1で構造を、パート2でビジネスロジックを構築いたしました。今回は、システムを安全にする重要な層である**セキュリティ**を追加いたします。
>
> 私どもは、Javaアプリケーションの業界標準フレームワークである**Spring Security**を使用しております。
>
> ### **SecurityConfig.java**
> ここで認証と認可を設定いたします：
>
> **1. パブリックエンドポイントと認証エンドポイント**
> ```java
> .authorizeHttpRequests(auth -> auth
>     .requestMatchers(\"/login\", \"/register\", \"/css/**\").permitAll()
>     .anyRequest().authenticated()
> )
> ```
> *   `/login`、`/register`、および静的CSSファイルはパブリックでございます。
> *   それ以外はすべて認証が必要でございます。
>
> **2. フォームベースログイン**
> ```java
> .formLogin(form -> form
>     .loginPage(\"/login\")
>     .defaultSuccessUrl(\"/properties\", true)
>     .failureUrl(\"/login?error=true\")
> )
> ```
> *   `/login`にカスタムログインページを配置。
> *   ログイン成功後、ユーザーは物件ダッシュボードに遷移いたします。
>
> **3. CSRF保護**
> ```java
> .csrf(csrf -> csrf
>     .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
> )
> ```
> *   クロスサイトリクエストフォージェリ攻撃から保護いたします。
> *   すべてのフォームにCSRFトークンを含める必要がございます。
>
> ### **パスワードセキュリティ**
> `UserServiceImpl`をご覧ください：
> ```java
> user.setPassword(passwordEncoder.encode(user.getPassword()));
> userMapper.insert(user);
> ```
> *   パスワードは**決して**平文で保存されません。
> *   **BCrypt**ハッシュ化を使用しております—一方向暗号化関数でございます。
> *   データベースが侵害されても、パスワードは安全に保たれます。
>
> ### **CustomUserDetailsService**
> このクラスは認証のためにデータベースからユーザーを読み込みます：
> ```java
> User user = userMapper.findByUsername(username);
> return new org.springframework.security.core.userdetails.User(
>     user.getUsername(),
>     user.getPassword(),
>     authorities
> );
> ```
> Spring Securityはログイン時にこのサービスを呼び出し、認証情報を検証いたします。
>
> ### **自動ログインフロー**
> 登録後、シームレスな体験を提供いたします：
> *   **標準的なフロー：** 登録 → ログインページへリダイレクト → 再度認証情報を入力 → ログイン。（摩擦がございます！）
> *   **私どものフロー：** 登録 → バックエンドがユーザーを作成 → **自動ログイン** → ダッシュボードへリダイレクト。（スムーズでございます！）
>
> これは`AuthController.register()`で実装されており、プログラム的に`SecurityContext`を作成し、セッションに保存いたします。」

---

## 例外処理とバリデーション（2分）

> 「本番システムはエラーを適切に処理する必要がございます。2種類のバリデーションがございます：
>
> ### **1. Bean Validationエラー**
> これらはコントローラーレベルでキャッチされます：
> ```java
> public String save(@Valid @ModelAttribute Property property,
>                    BindingResult bindingResult) {
>     if (bindingResult.hasErrors()) {
>         return \"properties/form\";  // エラー付きでフォームを再表示
>     }
>     // ... 保存ロジック
> }
> ```
> *   ユーザーが必須フィールドを空白で送信した場合、`@NotBlank`バリデーションが失敗いたします。
> *   フォームは各フィールドの横に特定のエラーメッセージと共に再表示されます。
> *   例：名前入力欄の横に「名前は必須です」と表示されます。
>
> ### **2. ビジネスロジックエラー**
> これらはサービス層によってスローされます：
> ```java
> try {
>     propertyService.createProperty(property);
> } catch (Exception e) {
>     bindingResult.reject(\"error\", e.getMessage());
>     return \"properties/form\";
> }
> ```
> *   `LeaseService`が`IllegalStateException`をスロー（例：「物件には既にアクティブな賃貸契約が存在します」）した場合、コントローラーがキャッチいたします。
> *   エラーメッセージはフォームに追加され、ユーザーに表示されます。
> *   これにより技術的な例外がユーザーフレンドリーなフィードバックに変換されます。
>
> **重要な原則：** ユーザーはスタックトレースや暗号的なエラーコードを見ることはございません。問題を解決するのに役立つ実用的なメッセージが表示されます。」

---

## 完全なエンドツーエンドデモ（5分）

> 「それでは、すべてが連携して動作する様子をライブデモでご覧いただきます。登録からビジネスルールの強制まで、システム全体をご案内いたします。
>
> ### **ステップ1：ユーザー登録と自動ログイン**
> *   `/register`に移動いたします。
> *   入力内容：ユーザー名：`manager@example.com`、パスワード：`secure123`
> *   「登録」をクリックいたします。
> *   **ご注目ください：** 再度ログインする必要なく、即座に`/properties`（ダッシュボード）にリダイレクトされます。
> *   **結果：** 自動ログインが機能いたしました！ユーザーは認証済みで作業を開始できます。
>
> ---
>
> ### **ステップ2：物件管理**
> **物件の作成：**
> *   「新規物件」をクリックいたします。
> *   入力内容：
>     - 名前：`サンセットアパートメント`
>     - 住所：`オーシャンドライブ123番地`
>     - エリア：`ダウンタウン`
>     - 間取り：`2LDK`
> *   「保存」をクリックいたします。
> *   **結果：** 物件が一覧に表示されます。
>
> **物件詳細の表示：**
> *   「サンセットアパートメント」をクリックいたします。
> *   **結果：** 詳細ページに物件情報と空の賃貸契約リスト（まだ賃貸契約がございません）が表示されます。
>
> ---
>
> ### **ステップ3：テナント管理**
> **テナントの作成：**
> *   `/tenants`に移動いたします。
> *   「新規テナント」をクリックいたします。
> *   入力内容：
>     - 氏名：`山田太郎`
>     - 電話：`555-1234`
>     - メール：`yamada@example.com`
> *   「保存」をクリックいたします。
> *   **結果：** テナントが一覧に表示されます。
>
> **別のテナントの作成：**
> *   `佐藤花子`（電話：`555-5678`、メール：`sato@example.com`）で繰り返します。
> *   **結果：** これで2人のテナントが登録されました。
>
> ---
>
> ### **ステップ4：賃貸契約管理 - 正常パス**
> **最初の賃貸契約を作成：**
> *   「新規賃貸契約」に移動いたします（または物件詳細ページから）。
> *   選択内容：
>     - 物件：`サンセットアパートメント`
>     - テナント：`山田太郎`
>     - ステータス：`ACTIVE`
>     - 賃料：`200000`
>     - 開始日：本日の日付
> *   「保存」をクリックいたします。
> *   **結果：** 賃貸契約が正常に作成されました。山田太郎様がサンセットアパートメントを現在賃借中でございます。
>
> ---
>
> ### **ステップ5：賃貸契約管理 - ビジネスルール違反**
> **2つ目のアクティブな賃貸契約を試行：**
> *   再度「新規賃貸契約」をクリックいたします。
> *   選択内容：
>     - 物件：`サンセットアパートメント`（同じ物件でございます！）
>     - テナント：`佐藤花子`（異なるテナント）
>     - ステータス：`ACTIVE`
>     - 賃料：`200000`
> *   「保存」をクリックいたします。
> *   **結果：** ❌ **エラーメッセージが表示されます：** 「賃貸契約を作成できません：物件には既にアクティブな賃貸契約が存在します」
> *   **説明：** サービス層が競合を検出し、操作を拒否いたしました。「1つのアクティブな賃貸契約」ルールが強制されております。
>
> ---
>
> ### **ステップ6：削除ガード - 物件**
> **アクティブな賃貸契約がある物件の削除を試行：**
> *   「サンセットアパートメント」詳細ページに戻ります。
> *   「物件を削除」をクリックいたします。
> *   **結果：** ❌ **エラーメッセージ：** 「有効な賃貸契約が存在するため、物件を削除できません」
> *   **説明：** コントローラーが`LeaseService`に確認し、データ整合性を保護するために削除をブロックいたしました。
>
> ---
>
> ### **ステップ7：削除ガード - テナント**
> **賃貸契約があるテナントの削除を試行：**
> *   `/tenants`に移動いたします。
> *   「山田太郎」を削除しようとします。
> *   **結果：** ❌ **エラーメッセージ：** 「賃貸契約が存在するため、入居者を削除できません」
> *   **説明：** テナントを削除したい場合でも、履歴的な契約データを消去することはできません。
>
> ---
>
> ### **ステップ8：バリデーションエラー**
> **フォームバリデーションのテスト：**
> *   「新規物件」をクリックいたします。
> *   「名前」と「住所」を空白のままにいたします。
> *   「保存」をクリックいたします。
> *   **結果：** フォームがエラーメッセージと共に再表示されます：「名前は必須です」、「住所は必須です」。
> *   **説明：** Bean Validationがサービス層に到達する前にエラーをキャッチいたしました。
>
> ---
>
> ### **最終まとめ**
> 以下を実演いたしました：
> 1.  ✅ **シームレスな認証：** 登録後の自動ログイン。
> 2.  ✅ **完全なCRUD：** 物件、テナント、賃貸契約すべてが管理可能。
> 3.  ✅ **ビジネスルールの強制：** 1物件につき1つのアクティブな賃貸契約。
> 4.  ✅ **データ整合性保護：** 削除ガードが孤立データを防止。
> 5.  ✅ **ユーザーフレンドリーなバリデーション：** 明確なエラーメッセージがユーザーを導きます。
>
> 本システムは以下を備えております：
> *   **レイヤードアーキテクチャ**による保守性。
> *   **サービスレベルルール**により回避不可能。
> *   **セキュアな認証**：BCryptとSpring Security。
> *   **洗練されたUX**：バリデーションフィードバックと自動ログイン。
>
> ご清聴ありがとうございました。」

